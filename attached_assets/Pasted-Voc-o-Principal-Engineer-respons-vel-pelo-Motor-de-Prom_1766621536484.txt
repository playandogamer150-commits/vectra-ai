VocÃª Ã© o Principal Engineer responsÃ¡vel pelo â€œMotor de Promptsâ€ da VectraÂ AI. ApÃ³s a correÃ§Ã£o do preview, notamos que os **filtros** (Aesthetic Intensity, UGC Realism, Layout Entropy, Camera Bias, Temporal Style, Prompt Length, Ã‚ngulo de CÃ¢mera, etc.) **nÃ£o estÃ£o impactando o prompt final** como esperado. Os valores selecionados ficam visÃ­veis na interface, mas nÃ£o influenciam o â€œcompiledPromptâ€ enviado Ã  geraÃ§Ã£o.

**Objetivo:** garantir que cada filtro selecionado se traduza em termos correspondentes no prompt gerado, seguindo a ordem preferida do perfil LLM e respeitando blueprint e regras de plano.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” DiagnÃ³stico inicial
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- Os filtros sÃ£o renderizados e podem ser selecionados, mas o estado `appliedFilters` nem sempre Ã© propagado para o serviÃ§o de geraÃ§Ã£o (/api/generate).
- O arquivo `src/core/prompt-engine/compiler.ts` concatena apenas os blocos do blueprint e ignora (ou mistura mal) os efeitos definidos em `filters.effect`.
- HÃ¡ mudanÃ§as recentes de internacionalizaÃ§Ã£o (PT/EN) que podem estar afetando as chaves dos filtros ou suas opÃ§Ãµes (`key` â‰  `label`).
- O back-end salva `appliedFilters` no banco, mas o campo `compiledPrompt` nÃ£o contÃ©m as frases correspondentes Ã  escolha do usuÃ¡rio.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Tarefas de correÃ§Ã£o
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **SincronizaÃ§Ã£o Front-End â†’ Back-End**  
   - Verifique o componente **FilterPanel** (provavelmente em `client/src/components/studio/FilterPanel.tsx`) para garantir que cada clique altera o objeto `appliedFilters` (chave:valor) no estado global (Zustand) ou props.  
   - Garanta que o hook `useGenerate` ou a chamada `generatePrompt` envia `appliedFilters` para `/api/generate` como parte do corpo da requisiÃ§Ã£o.

2. **Mapa de Efeitos (filters.effect)**  
   - No back-end (`server/core/prompt-engine/compiler.ts` ou similar), crie uma funÃ§Ã£o `applyFilters(filters: Record<string, string>, filterDefinitions: FilterDefinition[])` que:
     1. Percorre cada par `key:value` em `appliedFilters`.
     2. Busca o filtro correspondente em `filterDefinitions` (a lista fornecida pelo endpoint `/api/filters`).
     3. Insere o texto de `effect[value]` como um bloco de prompt na categoria correta.
   - Exemplo: se `camera_bias = cctv`, concatene â€œsecurity camera look, fisheye distortionâ€ Ã  seÃ§Ã£o *camera* do prompt. Se `prompt_length = long`, concatene â€œextended detailed descriptionâ€.  
   - Respeite a ordem definida em `LLMProfile.preferredOrder`. Se `preferredOrder` = ["subject","style","camera","layout","postfx","constraint"], encaixe cada filtro na categoria apropriada:
       - camera_bias, camera_angle â†’ categoria â€œcameraâ€
       - aesthetic_intensity, ugc_realism, temporal_style â†’ categoria â€œstyleâ€
       - layout_entropy â†’ â€œlayoutâ€
       - prompt_length â†’ â€œconstraintâ€ ou â€œpostfxâ€, conforme definido
   - NÃ£o repita blocos idÃªnticos vindos do blueprint.

3. **InternacionalizaÃ§Ã£o e Chaves**  
   - Use sempre a propriedade `key` do filtro para lÃ³gica e `label` apenas para exibiÃ§Ã£o.  
   - Para cada valor traduzido (ex.: â€œaltoâ€, â€œbaixoâ€), mapeie para a chave original (ex.: â€œhighâ€, â€œlowâ€) antes de buscar `effect[value]`.  
   - Ajuste o JSON de traduÃ§Ã£o se necessÃ¡rio para que as opÃ§Ãµes de filtro mantenham o valor (id) em inglÃªs.

4. **ValidaÃ§Ã£o de Inputs**  
   - No schema de validaÃ§Ã£o (`validator.ts`), assegure que apenas valores vÃ¡lidos (exatamente igual aos `options` do filtro) podem ser enviados. Retorne 400 caso contrÃ¡rio.

5. **Teste Completo**  
   - Crie testes unitÃ¡rios para `applyFilters()` com diferentes combinaÃ§Ãµes.  
   - Crie testes de integraÃ§Ã£o no front-end usando Cypress ou Jest/React Testing Library para verificar que:
       - Selecionar â€œextremeâ€ em Aesthetic Intensity adiciona â€œmaximum stylization, highly artisticâ€ ao prompt final.
       - Mudar para â€œbalancedâ€ em Layout Entropy muda o texto para â€œharmonious arrangement, natural flowâ€.
       - Selecionar â€œlongâ€ em Prompt Length adiciona â€œextended detailed descriptionâ€.

6. **UI Feedback**  
   - Mostre de forma clara quais filtros estÃ£o ativos.  
   - Se um usuÃ¡rio da versÃ£o Free ultrapassar o limite de filtros (p.ex. >3), bloqueie seleÃ§Ã£o adicional e mostre tooltip â€œAtualize para Proâ€.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ›  CritÃ©rio de Aceite
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- Todos os filtros selecionados impactam o `compiledPrompt`, seguindo o schema de efeitos e a ordem do LLM Profile.
- O `compiledPrompt` exibido no console e enviado para ModelsLab reflete exatamente a seleÃ§Ã£o do usuÃ¡rio.
- As traduÃ§Ãµes PT/EN nÃ£o quebram a lÃ³gica de mapeamento de filtros.
- Planos (Free vs Pro) limitam filtros conforme `profile/usage.limits`.
- Nenhuma regressÃ£o nos demais mÃ³dulos (Blueprints, LoRA, Video).

Implemente essa correÃ§Ã£o, execute testes, e garanta que a combinaÃ§Ã£o de filtros e prompts funcione de ponta a ponta.
